# RPC [original 1984 proposed paper](https://dl.acm.org/doi/10.1145/2080.357392)
- function implementation lives on server
- client wants to execute it.
- goal: transparent. looks like executing on own machine

- client: sends msg: marshalled into binary transmitable package.
- [[42e4cce2f4aae747c5e3f34e188484cd_MD5.jpeg|Open: Pasted image 20241020135520.png]]
![[42e4cce2f4aae747c5e3f34e188484cd_MD5.jpeg]]
- [[97e3959828ef355c67e869b7f4648648_MD5.jpeg|Open: Pasted image 20241020135403.png]]
![[97e3959828ef355c67e869b7f4648648_MD5.jpeg]]
- server: unmarshals msg, passes to app, sends fn(x,y) back to client

 Example Javascript RPC
< skip examples 12:00-16:00
```client
let args = {amount: 3.99, currency: 'GBP', /*...*/ }; //f(x,y)
let request = {
	method: 'POST',
	body: JSON.stringify(args),
	headers: {'Content-Type': 'application/json'}
};
fetch('https://example.com/payments', request)
	.then((response) => { //check status
		if (response.ok) success(response.json()); 
		else failure(response.status); // server error
})
.catch((error) => {
	failure(error); // network error
});
```
## RPC Benefits
- easy to use, familiar to programmers
- abstracts away network/marshal details in raw network sockets, endianess
## Failures
- client or server crash/reboot
- packet network loss, routing issues
- slow network/server
all look same to client
**3 failure-handling schemas**
- At-Least-Once
	- client gets no ACK, retry fixed # times until give up and ret error
	- **read-only**, otherwise retry misinterpreted by server as multiple requests
	- **idempotent**: or request can only happen once (i.e. create account)
- At-Most-Once
	- server responsible for detecting and rejecting dupe responses
	- transaction ID (XID)
		- client ID (IP) + time of day //prevents parallelism
		- unique ID + seq no // using IP bad unless small network
		- random # (practically doesn't work)
	- issues:
		- seen XIDS grow without bound!!!!
			- soln: 
		- dupe while still executing original?
		- server crash/restart?
```
	if seen[xid]:
		retval = old[xid] // get ret val in buffer of old responses
	else:
		retval = handler()
		old[xid] = retval //cache response in buffer
		seen[xid] = true //mark as seen before

	return retval
```
- Exactly-Once
# RPC [original 1984 proposed paper](https://dl.acm.org/doi/10.1145/2080.357392)
- function implementation lives on server
- client wants to execute it.
- goal: transparent. looks like executing on own machine

- client: sends msg: marshalled into binary transmitable package.
- [[42e4cce2f4aae747c5e3f34e188484cd_MD5.jpeg|Open: Pasted image 20241020135520.png]]
![[42e4cce2f4aae747c5e3f34e188484cd_MD5.jpeg]]
- [[97e3959828ef355c67e869b7f4648648_MD5.jpeg|Open: Pasted image 20241020135403.png]]
![[97e3959828ef355c67e869b7f4648648_MD5.jpeg]]
- server: unmarshals msg, passes to app, sends fn(x,y) back to client

 Example Javascript RPC
< skip examples 12:00-16:00
```client
let args = {amount: 3.99, currency: 'GBP', /*...*/ }; //f(x,y)
let request = {
	method: 'POST',
	body: JSON.stringify(args),
	headers: {'Content-Type': 'application/json'}
};
fetch('https://example.com/payments', request)
	.then((response) => { //check status
		if (response.ok) success(response.json()); 
		else failure(response.status); // server error
})
.catch((error) => {
	failure(error); // network error
});
```
## RPC Benefits
- easy to use, familiar to programmers
- abstracts away network/marshal details in raw network sockets, endianess
## Failures
- client or server crash/reboot
- packet network loss, routing issues
- slow network/server
all look same to client

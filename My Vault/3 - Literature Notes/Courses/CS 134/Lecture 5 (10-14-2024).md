
Time uses
- scheduling jobs cos, Hadoop)
    - timeout & retry
    - failure detection
- measuring performance
- TTL caches, time-sensitive data
- Order of events-timestamp weak to internet down

Clock Types
- physical (analog = pendulum, digital = oscillating crystal)
    - crystal cheap, inaccurate, temp-dependent
    - atomic uses cesium-133 or rubidium, GPS
    - adjusted to match Earth's variations (GTC)
        - June 30 & Dec 31 ± leap sec every year (23:59:58 → 00:00:00 or 23:59:59 → 60 or nop)
        - OS livelock @ 23:59: 60 confusion, disrupts hr timer to think all sleeping processes were sleeping too long due to OS neglect, wakes them all, overloads CPU with callbacks in Java
        - CMOS battery counts time even if PC off, crashes badly if it fails
    - fixing clock skew: minor inaccuracies btwn 2 computers
        - **NTP servers** strotums:
        - 0: atomic clock
        - 1: Ntp server built atop 0
        - 2: everything else built atop 1
		- ==**clock slew**==: gradually adjust client clock
		- gradually adjust bc sudden step may miss milestones or confuse hr timer to livelock![[Pasted image 20241102172029.png]]
		- if <125ms slew, elif <1000ms step bc too slow, else too big ask for human intervention
		- assumes symmetric, may not due to queue, so average out many requests? 
	- stepping clock skew issues due to diff types of software clocks
		- ==time-of-day (real-time)==: 02:00:00, error-prone, leap-second minus/plus etc
			- can be compared across nodes if in sync UNLIKE monotonic clock 
		- ==monotonic clock==: only counts forward, # seconds since arbitrary event --> nanoTime() in Java,
			- good for timing local stuff, but arbitrary means in relation to this computer only
	- ordering messages example
		- bank's data balance ($1000) replicated across two nodes, LA & NYC
		- LA user wants to deposit $100, NYC employee deposits 1% interest
		- LA then NYC: $1000+$100+$11=$1111
		- NYC then LA: $1000+$10+$100=$1110
		- how to find order if jumbled due to latency?
			- monotonic relative can't, real-time timestamps from each user non-synced/skewed
			- soln: ==**Happens-Before** ==
				- a --> b (a before b) iff:
					- single thread/node/process responsible for both a and b and a executed first
					![[Pasted image 20241102174858.png]]
					- or a = "sending msg" and b = "receiving msg"
					![[Pasted image 20241102174922.png]]
					- or exists event c such that a--> c and c-->b.  i.e. given image:
						- a-->c because a-->b and b-->c
						- a-->d because a-->b and b-->c and c-->d
						- etc. 
				- otherwise a||b, aka **concurrent**/independent,  not know which first or not)
					- a||e,  b||e,  c||e, d||e.  because all we know is e-->f but nothing is before e
			- broadcast: lots of complexity and order matters!
- logical clocks
	- designed to capture causal dependencies - # events NOT seconds
	- ==Lamport clocks== - seq no. not timestamp, logically monotonic 
		- assumes: single thread per node
		- each node counter t per local event
		- L(e) = current val of t at event e (right after incrementing to e)
		 1. t=0 
		 2. before executing/send/deliver event, increment that node's t
		 3. when node i --> j a message, t_i included in msg, then node j updates t_j = max(t_i, t_j)+1
		- if a --> b,  then L(a) < L(b) but not guaranteed vice versa
		- psuedocode:
			- ![[Pasted image 20241102180554.png]]
		- 